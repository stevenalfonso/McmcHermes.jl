var documenterSearchIndex = {"docs":
[{"location":"#McmcHermes.jl","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"","category":"section"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"A documentation for the McmcHermes package.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"McmcHermes is a pure-Julia implementation of Metropolis Hasting Algorithm under an MIT license. McmcHermes will help you if you want to estimate model parameters or sample a probability density distribution.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"","category":"page"},{"location":"#Installation","page":"McmcHermes.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"using Pkg\nPkg.add(\"McmcHermes\")","category":"page"},{"location":"#Basic-Usage","page":"McmcHermes.jl","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"note: Note\nThis guide assumes that you already have define your likelihood, prior and the logarithm of the posterior probability as in the example below.","category":"page"},{"location":"#Sampling","page":"McmcHermes.jl","title":"Sampling","text":"","category":"section"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"If you want to draw samples from two Gaussian distributions, you would do something like:","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"function pdf(X::Number, params::Vector)\n    s1, s2, mu1, mu2 = params[1], params[2], params[3], params[4]\n    return 1 / (sqrt(2 * pi) * s1) * exp( -0.5*((X - mu1)/s1)^2 ) + 1 / (sqrt(2 * pi) * s2) * exp( -0.5*((X - mu2)/s2)^2 )\nend\n\nfunction gaussian_function(X::Vector, params::Vector)\n    x_values = collect(range(minimum(X), maximum(X), length=length(X)))\n    s1, s2, mu1, mu2 = params[1], params[2], params[3], params[4]\n    return 0.5 ./ (sqrt(2 * pi) .* s1) .* exp.(-0.5*((x_values .- mu1)./s1).^2) .+ 0.5 ./ (sqrt(2 * pi) .* s2) .* exp.(-0.5*((x_values .- mu2)./s2).^2)\nend\n\nusing McmcHermes\n\nparams = [3, 1.5, -5, 5]\ninterval = [-20, 20]\nsampling = McmcHermes.sampler(pdf, 10000, interval, params)\n\nx_values = Vector{Float64}(range(interval[1], interval[2], 100))\n\nhistogram(sampling, xlabel=L\"samples\", ylabel=L\"p(x)\", xguidefontsize=12, color=:gray, yguidefontsize=12, normalize=:pdf, show=true, label=\"samples\")\nplot!(x_values, gaussian_function(x_values, params), lw=3, size=(500,400), label=\"Function\", lc=:orange, show=true)","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"(Image: samples)","category":"page"},{"location":"#Parameter-estimation","page":"McmcHermes.jl","title":"Parameter estimation","text":"","category":"section"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"McmcHermes can be used to estimate parameters from a model. For instance, from one of my papers A Gaia astrometric view of the open clusters, Pleiades, Praesepe, and Blanco 1; the estimation of the nine parameters of the assumed proper motions model can be estimated through McmcHermes.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"The log-likelihood of the proper motions model is defined as","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"$","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"\\begin{aligned} \\log \\mathcal{L}(x, y \\mid \\theta) &= \\sum \\log \\left[ A{\\text{circ}} \\cdot \\exp\\left( -\\frac{1}{2} \\left( \\frac{x - \\mu{xc}}{s} \\right)^2 + \\left( \\frac{y - \\mu{yc}}{s} \\right)^2 \\right) \\right. \\\n&\\quad + \\left. A{\\text{elip}} \\cdot \\exp\\left( -\\frac{1}{2(1 - \\rho^2)} \\left[ \\left( \\frac{x - \\mu{xf}}{sx} \\right)^2 + \\left( \\frac{y - \\mu{yf}}{sy} \\right)^2 - 2\\rho \\left( \\frac{x - \\mu{xf}}{sx} \\right) \\left( \\frac{y - \\mu{yf}}{sy} \\right) \\right] \\right) \\right] \\end{aligned} $","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"with  $ A{\\text{circ}} = \\frac{nc}{2\\pi s^2} $","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"$","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"A{\\text{elip}} = \\frac{1 - nc}{2\\pi sx sy \\sqrt{1 - \\rho^2}} $","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"That function depends on nine parameters","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"$","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"nc,\\quad s,\\quad sx,\\quad sy,\\quad \\rho,\\quad \\mu{xc},\\quad \\mu{yc},\\quad \\mu{xf},\\quad \\mu_{yf} $","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"Let's now estimate them by using the McmcHermes package. First, here is the plot of the proper motions in the field of the Pleiades open cluster","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"using Distributions, Plots, LaTeXStrings, DataFrames, CSV\n\ndf = DataFrame(CSV.File(\"./pleiades_field-result.csv\"))\npleiades_field = df[(df.pmra .>= 10) .& (df.pmra .<= 30) .& (df.pmdec .>= -55) .& (df.pmdec .<= -35), :]\n\nx = pleiades_field[!,:pmra]\ny = pleiades_field[!,:pmdec]\nscatter(x, y, title=\"Pleiades Proper Motions\", xlabel=\"pmra\", ylabel=\"pmdec\", legend=false, markersize=2)","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"(Image: data)","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"You can download the Pleiades field data from the Gaia Archive by using this query","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"SELECT * FROM gaiadr3.gaia_source AS gaia \nWHERE CONTAINS(POINT('ICRS',gaia.ra,gaia.dec), CIRCLE('ICRS', 56.85, 23.51, 5))=1\nAND gaia.visibility_periods_used > 6 AND gaia.pmra IS NOT NULL AND gaia.pmra != 0 \nAND gaia.pmdec IS NOT NULL AND gaia.pmdec != 0 AND gaia.parallax IS NOT NULL AND gaia.ruwe < 1.4\nAND gaia.parallax_over_error > 10 AND gaia.astrometric_params_solved > 3\nAND gaia.parallax >= 2","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"Now, we define the likelihood and prior","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"function log_likelihood(X::Vector, params::Vector)\n    x, y = X[1], X[2]\n    nc, s, sx, sy, rho = params[1], params[2], params[3], params[4], params[5]\n    mu_xc, mu_yc, mu_xf, mu_yf = params[6], params[7], params[8], params[9]\n    amp_circ = nc ./ (2 * pi .* s.^2)\n    amp_elip = (1-nc) ./ (2 * pi * sx * sy * sqrt(1 - rho.^2))\n    Exp_circ = -0.5 * (((x .- mu_xc)./s).^2 .+ ((y .- mu_yc)./s).^2)\n    Exp_elip = -1 ./ (2*(1-rho.^2)) .* (((x .- mu_xf)./sx).^2\n        .+ ((y .- mu_yf)./sy).^2 .- 2 * rho * ((x .- mu_xf)./sx) .* ((y .- mu_yf)./sy))\n    z = amp_circ .* exp.(Exp_circ) + amp_elip .* exp.(Exp_elip)\n    return sum(log.(z))\nend\n\nfunction log_prior(params::Vector)\n    nc, s, sx, sy, rho = params[1], params[2], params[3], params[4], params[5]\n    mu_xc, mu_yc, mu_xf, mu_yf = params[6], params[7], params[8], params[9]\n    if 0.0 < nc < 1.0 && 0.0 < s < 10.0 && 0.0 < sx < 10.0 && 0.0 < sy < 10.0 && -1.0 < rho < 1.0\n        return 0.0\n    end\n    return -Inf\nend\n\nfunction log_probability(X::Vector, params::Vector)\n    x, y = X[1], X[2]\n    lp = log_prior(params)\n    if !isfinite(lp)\n        return -Inf\n    end\n    return lp + log_likelihood(X, params)\nend","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"First, let's apply the Maximum Likelihood Estimation to get a good initial guess","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"using Optim\n\nmake_closures(X) = params -> -log_likelihood(X, params)\ndata = [x, y]\nnc, s, sx, sy, rho = 0.5, 1.0, 5.0, 5.0, 0.1\nmu_xc, mu_yc, mu_xf, mu_yf = 20, -45, 20, -45\ninitparams = Vector{Float64}([nc, s, sx, sy, rho, mu_xc, mu_yc, mu_xf, mu_yf])\nnll = make_closures(data)\nopt_pm = optimize(nll, initparams, NelderMead(), autodiff=:forward)\nmle_params = Optim.minimizer(opt_pm)\nprintln(\"mle_params: \", mle_params) # [0.5703616168913359, 1.145121636314209, 4.683106119784698, 5.1177766210904485, -0.16776744025292578, 19.891677759318622, -45.419917930062915, 19.632955307887066, -43.415932987439774]","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"Then, define the number of walkers, iterations, dimension of the parameter space and the initial guess. Here we use the initial guess obtained from the MLE.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"using McmcHermes\n\nn_iter, n_walkers = 5000, 50\nn_dim = 9\nseed = rand(n_walkers, n_dim) * 1e-4 .+ transpose(mle_params)\n\nchains = McmcHermes.run_mcmc(log_probability, data, seed, n_iter, n_walkers, n_dim, a=0.01)\n\nprintln(size(chains)) # (5000, 50, 9)","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"The convergence of the chains can be validated by the Gelman-Rubin's diagnostic:","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"println(\"Gelman Rubin Diagnostic: \", McmcHermes.get_gelman_rubin(chains)) # 1.1161957469617692","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"Finally, plot the corner plot with the chains.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"flat_chains = McmcHermes.get_flat_chain(chains, burn_in=100, thin=10)\nprintln(size(flat_chains)) # (24901, 9)\n\nusing PairPlots, CairoMakie\n\nlabels = Dict(\n    :nc     => L\"n_c\",\n    :s      => L\"s\",\n    :sx     => L\"s_x\",\n    :sy     => L\"s_y\",\n    :rho    => L\"\\rho\",\n    :mu_xc  => L\"\\mu_{xc}\",\n    :mu_yc  => L\"\\mu_{yc}\",\n    :mu_xf  => L\"\\mu_{xf}\",\n    :mu_yf  => L\"\\mu_{yf}\"\n)\n\nparameters = (:nc, :s, :sx, :sy, :rho, :mu_xc, :mu_yc, :mu_xf, :mu_yf)\ndata = NamedTuple{parameters}(eachcol(flat_chains))\npairplot(data; labels=labels, axis=(xlabelsize=18, ylabelsize=18))","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"(Image: corner)","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"Developed by J. Alfonso.","category":"page"},{"location":"","page":"McmcHermes.jl","title":"McmcHermes.jl","text":"","category":"page"}]
}
